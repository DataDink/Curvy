<h3>Observables</h3>
<p>
   One of my deviations from the way Angular does things is that Curvy monitors
   changes in view models and objects by listening to change notification events
   instead of scanning objects for changes when various events in the framework
   occur. This, however, means that the objects it is listening for
   value changes on must be wrapped with or converted into an observable object.
</p>
<p>
   Observables take advantage of javascript's Property functionality. Properties, while
   appearing to work just like normal members on an object, actually fire off methods
   when you are getting or settings their values. This allows Curvy to react to changes
   made by intercepting value changes on your models and view models.
</p>
<p>
   View models will be auto-converted into observables after they have been constructed.
   This is done by replacing any values you set on the "this" object during construction
   with matching notification properties.
</p>
<p>
   There are both advantages and disadvantages to doing things this way:
</p>
<em>Disadvantages</em>
<ul>
   <li>
      You must convert or proxy any child-objects of your view-model if you want the
      descendant members to trigger UI updates when changed.
   </li>
   <li>
      New members can not be added to an observable after it has been sealed.
   </li>
</ul>
<em>Advantages</em>
<ul>
   <li>Change responses are triggered by a change to the value instead of framework events</li>
   <li>You are not required to wrap base javascript services such as setTimeout or setInterval</li>
   <li>Your UI doesn't get out of sync with your view-model</li>
</ul>
<h3>Making Observables</h3>
<p>
   Observables can be constructed using the <em>Curvy.Observable()</em> constructor.
</p>
<p class="container-fluid">
   <strong class="col-sm-3">Create</strong>
   <span class="col-sm-9">
      <strong>new Curvy.Observable()</strong><br />
      Using the Observable constructor you can create a new observable.
      Notifications will not begin until the Observable has been sealed.
      An observable can be sealed using the <em>.seal()</em> function.
      Once sealed, an observable can no longer have new members/properties added to it.
   </span>
</p>
<div class="container-fluid">
   <pre class="col-sm-9 col-sm-offset-3">
var observable = new Curvy.Observable();
observable.value = 'test';
observable.observe(function(member) { console.log(member + ' has changed value.'); });
observable.seal();

observable.value = 'test2';
   </pre>
</div>
<p class="container-fluid">
   <strong class="col-sm-3">Surrogate</strong>
   <span class="col-sm-9">
      <strong>new Curvy.Observable(proxy)</strong><br />
      An existing object can be proxied by an observable. This can be used to unobtrusively
      wrap an exiting object with a surrogate observable. The members of the observable will
      always return the values of the original object but will only notify observers when
      the values are set via the observable wrapper.
   </span>
</p>
<div class="container-fluid">
   <pre class="col-sm-9 col-sm-offset-3">
var proxied = {value: 'test'};
var surrogate = new Curvy.Observable(proxied);
surrogate.observe(function(member) { console.log(member + ' has changed value.'); });
surrogate.seal();

proxied.value = 'will not be observed';
surrogate.value = 'will be observed';
   </pre>
</div>
